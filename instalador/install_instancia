#!/bin/bash
# Script para instala칞칚o de uma nova inst칙ncia

# Definir vari치veis de ambiente
export PROJECT_ROOT=$(pwd)

# Incluir arquivos necess치rios
source "${PROJECT_ROOT}"/variables/_app.sh
source "${PROJECT_ROOT}"/variables/_general.sh
source "${PROJECT_ROOT}"/variables/_background.sh
source "${PROJECT_ROOT}"/variables/_fonts.sh
source "${PROJECT_ROOT}"/utils/_banner.sh
source "${PROJECT_ROOT}"/lib/_backend.sh
source "${PROJECT_ROOT}"/lib/_frontend.sh
source "${PROJECT_ROOT}"/lib/_system.sh
source "${PROJECT_ROOT}"/lib/_inquiry.sh

# Definir o link do git automaticamente
link_git="git@github.com:fuwork/chat-atendente.git"

# Fun칞칚o para verificar e configurar o Docker Swarm
system_check_swarm() {
  print_banner
  printf "${WHITE} 游눹 Verificando se o Docker est치 no modo Swarm...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  # Verificar se o Docker est치 no modo Swarm
  swarm_status=$(docker info --format '{{.Swarm.LocalNodeState}}')
  
  if [ "$swarm_status" != "active" ]; then
    printf "${RED}Docker n칚o est치 no modo Swarm. Inicializando...${NC}\n"
    sudo docker swarm init
    printf "${GREEN}Docker Swarm inicializado!${NC}\n"
  else
    printf "${GREEN}Docker j치 est치 no modo Swarm!${NC}\n"
  fi

  # Verificar se a rede network_public existe
  if ! docker network ls | grep -q "network_public"; then
    printf "${RED}Rede network_public n칚o encontrada. Criando...${NC}\n"
    docker network create --driver=overlay --attachable network_public
    printf "${GREEN}Rede network_public criada!${NC}\n"
  else
    printf "${GREEN}Rede network_public j치 existe!${NC}\n"
  fi

  # Verificar se o volume para certificados existe
  if ! docker volume ls | grep -q "volume_swarm_certificates"; then
    printf "${RED}Volume volume_swarm_certificates n칚o encontrado. Criando...${NC}\n"
    docker volume create volume_swarm_certificates
    printf "${GREEN}Volume volume_swarm_certificates criado!${NC}\n"
  else
    printf "${GREEN}Volume volume_swarm_certificates j치 existe!${NC}\n"
  fi

  # Verificar se o volume compartilhado existe
  if ! docker volume ls | grep -q "volume_swarm_shared"; then
    printf "${RED}Volume volume_swarm_shared n칚o encontrado. Criando...${NC}\n"
    docker volume create volume_swarm_shared
    printf "${GREEN}Volume volume_swarm_shared criado!${NC}\n"
  else
    printf "${GREEN}Volume volume_swarm_shared j치 existe!${NC}\n"
  fi

  sleep 2
}

# Fun칞칚o para verificar o status da implanta칞칚o
verify_deployment() {
  print_banner
  printf "${WHITE} 游눹 Verificando status dos servi칞os...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  printf "${YELLOW}Status do Redis:${NC}\n"
  docker service ls | grep redis-${instancia_add}
  
  printf "\n${YELLOW}Status do Backend:${NC}\n"
  docker service ls | grep ${instancia_add}-backend
  
  printf "\n${YELLOW}Status do Frontend:${NC}\n"
  docker service ls | grep ${instancia_add}-frontend
  
  printf "\n${YELLOW}Logs do Backend:${NC}\n"
  docker service logs ${instancia_add}-backend_${instancia_add}-backend --tail 10 2>/dev/null || echo "Ainda n칚o h치 logs dispon칤veis"
  
  printf "\n${YELLOW}Logs do Frontend:${NC}\n"
  docker service logs ${instancia_add}-frontend_${instancia_add}-frontend --tail 10 2>/dev/null || echo "Ainda n칚o h치 logs dispon칤veis"
  
  printf "\n${GREEN}Verifica칞칚o conclu칤da! Acesse sua aplica칞칚o em:${NC}\n"
  printf "${CYAN_LIGHT}Frontend: ${frontend_url}${NC}\n"
  printf "${CYAN_LIGHT}Backend: ${backend_url}${NC}\n"
}

# Fun칞칚o para configurar o backend com Traefik
backend_traefik_setup() {
  print_banner
  printf "${WHITE} 游눹 Configurando Traefik (backend)...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  backend_hostname=$(echo "${backend_url/https:\/\/}")

  # Criar arquivo docker-compose para o backend
  sudo su - deploy << EOF
  cat > /home/deploy/${instancia_add}/backend/docker-compose.yml << 'END'
version: '3.7'

services:
  ${instancia_add}-backend:
    image: node:20
    working_dir: /app
    volumes:
      - ./:/app
    command: node dist/server.js
    networks:
      - network_public
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.${instancia_add}-backend.rule=Host(\`${backend_hostname}\`)"
        - "traefik.http.routers.${instancia_add}-backend.entrypoints=websecure"
        - "traefik.http.services.${instancia_add}-backend.loadbalancer.server.port=${backend_port}"
        - "traefik.http.routers.${instancia_add}-backend.tls=true"
        - "traefik.http.routers.${instancia_add}-backend.tls.certresolver=letsencryptresolver"
        - "traefik.docker.network=network_public"

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o container como um servi칞o no swarm
  cd /home/deploy/${instancia_add}/backend
  docker stack deploy -c docker-compose.yml ${instancia_add}-backend
EOF

  sleep 2
}

# Fun칞칚o para configurar o frontend com Traefik
frontend_traefik_setup() {
  print_banner
  printf "${WHITE} 游눹 Configurando Traefik (frontend)...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  frontend_hostname=$(echo "${frontend_url/https:\/\/}")

  # Criar arquivo docker-compose para o frontend
  sudo su - deploy << EOF
  cat > /home/deploy/${instancia_add}/frontend/docker-compose.yml << 'END'
version: '3.7'

services:
  ${instancia_add}-frontend:
    image: node:20
    working_dir: /app
    volumes:
      - ./:/app
    command: node server.js
    networks:
      - network_public
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.${instancia_add}-frontend.rule=Host(\`${frontend_hostname}\`)"
        - "traefik.http.routers.${instancia_add}-frontend.entrypoints=websecure"
        - "traefik.http.services.${instancia_add}-frontend.loadbalancer.server.port=${frontend_port}"
        - "traefik.http.routers.${instancia_add}-frontend.tls=true"
        - "traefik.http.routers.${instancia_add}-frontend.tls.certresolver=letsencryptresolver"
        - "traefik.docker.network=network_public"

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o container como um servi칞o no swarm
  cd /home/deploy/${instancia_add}/frontend
  docker stack deploy -c docker-compose.yml ${instancia_add}-frontend
EOF

  sleep 2
}

# Modifica칞칚o da fun칞칚o backend_redis_create
backend_redis_create() {
  print_banner
  printf "${WHITE} 游눹 Criando Redis & Banco Postgres...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  # Criar docker-compose.yml para o Redis
  sudo su - deploy << EOF
  mkdir -p /home/deploy/${instancia_add}/redis
  cat > /home/deploy/${instancia_add}/redis/docker-compose.yml << 'END'
version: '3.7'

services:
  redis-${instancia_add}:
    image: redis:latest
    command: redis-server --requirepass ${mysql_root_password}
    networks:
      - network_public
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o Redis como servi칞o no swarm
  cd /home/deploy/${instancia_add}/redis
  docker stack deploy -c docker-compose.yml redis-${instancia_add}
EOF

  sleep 2

  # Configurar o banco de dados PostgreSQL
  sudo su - root <<EOF
  sudo su - postgres
  createdb ${instancia_add};
  psql
  CREATE USER ${instancia_add} SUPERUSER INHERIT CREATEDB CREATEROLE;
  ALTER USER ${instancia_add} PASSWORD '${mysql_root_password}';
  \q
  exit
EOF

  sleep 2
}

# Modificar a fun칞칚o backend_set_env para usar o Redis em Docker Swarm
backend_set_env_modified() {
  print_banner
  printf "${WHITE} 游눹 Configurando vari치veis de ambiente (backend)...${GRAY_LIGHT}"
  printf "\n\n"

  sleep 2

  # ensure idempotency
  backend_url=$(echo "${backend_url/https:\/\/}")
  backend_url=${backend_url%%/*}
  backend_url=https://$backend_url

  # ensure idempotency
  frontend_url=$(echo "${frontend_url/https:\/\/}")
  frontend_url=${frontend_url%%/*}
  frontend_url=https://$frontend_url

sudo su - deploy << EOF
  cat <<[-]EOF > /home/deploy/${instancia_add}/backend/.env
NODE_ENV=
BACKEND_URL=${backend_url}
FRONTEND_URL=${frontend_url}
PROXY_PORT=443
PORT=${backend_port}

DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=${instancia_add}
DB_PASS=${mysql_root_password}
DB_NAME=${instancia_add}

JWT_SECRET=${jwt_secret}
JWT_REFRESH_SECRET=${jwt_refresh_secret}

REDIS_URI=redis://:${mysql_root_password}@redis-${instancia_add}_redis-${instancia_add}:6379
REDIS_OPT_LIMITER_MAX=1
REGIS_OPT_LIMITER_DURATION=3000

USER_LIMIT=${max_user}
CONNECTIONS_LIMIT=${max_whats}
CLOSED_SEND_BY_ME=true

[-]EOF
EOF

  sleep 2
}

# Executar processo de instala칞칚o
print_banner
inquiry_options

# Continuar apenas se a op칞칚o 0 (instalar) foi selecionada
if [ -n "$instancia_add" ]; then
  # Verificar e configurar o modo Swarm
  system_check_swarm
  
  # Clonar o reposit칩rio
  system_git_clone
  
  # Configurar Redis e banco de dados
  backend_redis_create
  
  # Configurar vari치veis de ambiente
  backend_set_env_modified  # Usar a vers칚o modificada para Docker Swarm
  
  # Instalar depend칡ncias e construir o backend
  backend_node_dependencies
  backend_node_build
  backend_db_migrate
  backend_db_seed
  
  # Configurar Traefik para o backend
  backend_traefik_setup
  
  # Configurar o frontend
  frontend_set_env
  frontend_node_dependencies
  frontend_node_build
  
  # Configurar Traefik para o frontend
  frontend_traefik_setup
  
  # Verificar o status da implanta칞칚o
  verify_deployment

  printf "${GREEN}Instala칞칚o da inst칙ncia ${instancia_add} conclu칤da com sucesso!${NC}\n"
fi