#!/bin/bash
# Script para instala칞칚o de uma nova inst칙ncia

# Definir vari치veis de ambiente
export PROJECT_ROOT=$(pwd)
export LOG_FILE="/var/log/atendechat_install.log"

# Fun칞칚o de logging
log() {
  local message="$1"
  local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
  echo "[$timestamp] $message" | tee -a "$LOG_FILE"
}

log_error() {
  local message="$1"
  local timestamp=$(date +"%Y-%m-%d %H:%M:%S")
  echo "[$timestamp] ERROR: $message" | tee -a "$LOG_FILE" >&2
}

# Configurar permiss칫es do arquivo de log
sudo touch "$LOG_FILE"
sudo chmod 666 "$LOG_FILE"

# Registrar in칤cio da instala칞칚o
log "Iniciando processo de instala칞칚o de nova inst칙ncia do Atendechat"
log "Projeto raiz: $PROJECT_ROOT"

# Incluir arquivos necess치rios
source "${PROJECT_ROOT}"/variables/_app.sh
source "${PROJECT_ROOT}"/variables/_general.sh
source "${PROJECT_ROOT}"/variables/_background.sh
source "${PROJECT_ROOT}"/variables/_fonts.sh
source "${PROJECT_ROOT}"/utils/_banner.sh
source "${PROJECT_ROOT}"/lib/_backend.sh
source "${PROJECT_ROOT}"/lib/_frontend.sh
source "${PROJECT_ROOT}"/lib/_system.sh
source "${PROJECT_ROOT}"/lib/_inquiry.sh

# Definir o link do git automaticamente
# Preferimos SSH agora que est치 configurado corretamente
link_git="git@github.com:fuwork/chat-atendente.git"
# Alternativa: use HTTPS se a configura칞칚o SSH n칚o funcionar
# link_git="https://github.com/fuwork/chat-atendente.git"
# Caminho local caso o reposit칩rio j치 esteja na m치quina
codigo_fonte_local="/root/containers/chat-atendente"
log "Link do reposit칩rio Git: $link_git"
log "Caminho do c칩digo fonte local: $codigo_fonte_local"

# Fun칞칚o para configurar SSH para GitHub
setup_github_ssh() {
  print_banner
  printf "${WHITE} 游눹 Configurando acesso SSH para GitHub...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando acesso SSH para GitHub"

  sleep 2

  # Verificar se o usu치rio deploy j치 tem uma chave SSH
  if sudo su - deploy -c "[ -f ~/.ssh/id_ed25519 ]"; then
    log "Chave SSH j치 existe para o usu치rio deploy"
    printf "${GREEN}Chave SSH j치 existe para o usu치rio deploy.${NC}\n"
  else
    log "Gerando nova chave SSH para o usu치rio deploy"
    printf "${YELLOW}Gerando nova chave SSH para o usu치rio deploy...${NC}\n"
    
    # Gerar chave SSH sem senha para automa칞칚o
    sudo su - deploy -c "mkdir -p ~/.ssh && ssh-keygen -t ed25519 -f ~/.ssh/id_ed25519 -N '' -C 'deploy@$(hostname)'" >> "$LOG_FILE" 2>&1
    
    if [ $? -ne 0 ]; then
      log_error "Falha ao gerar chave SSH"
      printf "${RED}Falha ao gerar chave SSH. Verifique o log para mais detalhes.${NC}\n"
      return 1
    fi
    
    # Exibir a chave p칰blica para o usu치rio adicionar ao GitHub
    printf "${WHITE}============================================================${NC}\n"
    printf "${WHITE}IMPORTANTE: Adicione esta chave SSH ao GitHub antes de continuar${NC}\n"
    printf "${WHITE}============================================================${NC}\n\n"
    printf "${CYAN_LIGHT}Chave p칰blica SSH (copie e adicione ao GitHub):${NC}\n\n"
    sudo su - deploy -c "cat ~/.ssh/id_ed25519.pub"
    printf "\n\n"
    printf "${WHITE}============================================================${NC}\n"
    printf "${WHITE}Instru칞칫es:${NC}\n"
    printf "${WHITE}1. Copie a chave acima${NC}\n"
    printf "${WHITE}2. Acesse GitHub > Settings > SSH and GPG keys > New SSH key${NC}\n"
    printf "${WHITE}3. Cole a chave e adicione${NC}\n"
    printf "${WHITE}============================================================${NC}\n\n"
    
    # Perguntar se o usu치rio j치 adicionou a chave
    read -p "Voc칡 j치 adicionou a chave ao GitHub? (s/n): " ssh_added
    if [[ $ssh_added != "s" && $ssh_added != "S" ]]; then
      log_error "Usu치rio n칚o adicionou a chave SSH ao GitHub"
      printf "${RED}Por favor, adicione a chave SSH ao GitHub antes de continuar.${NC}\n"
      return 1
    fi
  fi
  
  # Configurar GitHub no known_hosts para evitar prompts
  sudo su - deploy -c "mkdir -p ~/.ssh && ssh-keyscan -t rsa github.com >> ~/.ssh/known_hosts" >> "$LOG_FILE" 2>&1
  
  # Testar a conex칚o com GitHub
  log "Testando conex칚o SSH com GitHub"
  printf "${YELLOW}Testando conex칚o SSH com GitHub...${NC}\n"
  
  ssh_test=$(sudo su - deploy -c "ssh -T -o BatchMode=yes -o StrictHostKeyChecking=no git@github.com 2>&1")
  
  if echo "$ssh_test" | grep -q "successfully authenticated"; then
    log "Conex칚o SSH com GitHub estabelecida com sucesso"
    printf "${GREEN}Conex칚o SSH com GitHub estabelecida com sucesso!${NC}\n"
    return 0
  else
    log_error "Falha na conex칚o SSH com GitHub: $ssh_test"
    printf "${RED}Falha na conex칚o SSH com GitHub. Tentaremos usar HTTPS.${NC}\n"
    
    # Mudar para HTTPS se SSH falhar
    link_git="https://github.com/fuwork/chat-atendente.git"
    log "Alternando para HTTPS: $link_git"
    printf "${YELLOW}Alternando para HTTPS: $link_git${NC}\n"
    return 1
  fi
}

# Fun칞칚o para configurar Git para o usu치rio deploy
setup_git_config() {
  print_banner
  printf "${WHITE} 游눹 Configurando Git para o usu치rio deploy...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando Git para o usu치rio deploy"

  sleep 2
  
  sudo su - deploy -c "git config --global user.name 'Deploy User'" >> "$LOG_FILE" 2>&1
  sudo su - deploy -c "git config --global user.email 'deploy@$(hostname)'" >> "$LOG_FILE" 2>&1
  
  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar Git para o usu치rio deploy"
    printf "${RED}Falha ao configurar Git para o usu치rio deploy.${NC}\n"
    return 1
  else
    log "Git configurado com sucesso para o usu치rio deploy"
    printf "${GREEN}Git configurado com sucesso para o usu치rio deploy!${NC}\n"
    return 0
  fi
}

# Fun칞칚o para verificar e configurar o Docker Swarm
system_check_swarm() {
  print_banner
  printf "${WHITE} 游눹 Verificando se o Docker est치 no modo Swarm...${GRAY_LIGHT}"
  printf "\n\n"
  log "Verificando configura칞칚o do Docker Swarm"

  sleep 2

  # Verificar se o Docker est치 no modo Swarm
  swarm_status=$(docker info --format '{{.Swarm.LocalNodeState}}' 2>>"$LOG_FILE")
  
  if [ "$swarm_status" != "active" ]; then
    log_error "Docker n칚o est치 no modo Swarm. Inicializando..."
    printf "${RED}Docker n칚o est치 no modo Swarm. Inicializando...${NC}\n"
    sudo docker swarm init 2>>"$LOG_FILE"
    log "Docker Swarm inicializado!"
    printf "${GREEN}Docker Swarm inicializado!${NC}\n"
  else
    log "Docker j치 est치 no modo Swarm"
    printf "${GREEN}Docker j치 est치 no modo Swarm!${NC}\n"
  fi

  # Verificar se a rede network_public existe
  if ! docker network ls 2>>"$LOG_FILE" | grep -q "network_public"; then
    log_error "Rede network_public n칚o encontrada. Criando..."
    printf "${RED}Rede network_public n칚o encontrada. Criando...${NC}\n"
    docker network create --driver=overlay --attachable network_public 2>>"$LOG_FILE"
    log "Rede network_public criada!"
    printf "${GREEN}Rede network_public criada!${NC}\n"
  else
    log "Rede network_public j치 existe"
    printf "${GREEN}Rede network_public j치 existe!${NC}\n"
  fi

  # Verificar se o volume para certificados existe
  if ! docker volume ls 2>>"$LOG_FILE" | grep -q "volume_swarm_certificates"; then
    log_error "Volume volume_swarm_certificates n칚o encontrado. Criando..."
    printf "${RED}Volume volume_swarm_certificates n칚o encontrado. Criando...${NC}\n"
    docker volume create volume_swarm_certificates 2>>"$LOG_FILE"
    log "Volume volume_swarm_certificates criado!"
    printf "${GREEN}Volume volume_swarm_certificates criado!${NC}\n"
  else
    log "Volume volume_swarm_certificates j치 existe"
    printf "${GREEN}Volume volume_swarm_certificates j치 existe!${NC}\n"
  fi

  # Verificar se o volume compartilhado existe
  if ! docker volume ls 2>>"$LOG_FILE" | grep -q "volume_swarm_shared"; then
    log_error "Volume volume_swarm_shared n칚o encontrado. Criando..."
    printf "${RED}Volume volume_swarm_shared n칚o encontrado. Criando...${NC}\n"
    docker volume create volume_swarm_shared 2>>"$LOG_FILE"
    log "Volume volume_swarm_shared criado!"
    printf "${GREEN}Volume volume_swarm_shared criado!${NC}\n"
  else
    log "Volume volume_swarm_shared j치 existe"
    printf "${GREEN}Volume volume_swarm_shared j치 existe!${NC}\n"
  fi

  sleep 2
}

# Fun칞칚o modificada para criar as pastas do projeto e clonar o reposit칩rio
system_git_clone_modified() {
  print_banner
  printf "${WHITE} 游눹 Criando estrutura de diret칩rios e copiando o c칩digo Atendechat...${GRAY_LIGHT}"
  printf "\n\n"
  log "Criando estrutura de diret칩rios e copiando o c칩digo Atendechat"

  sleep 2

  # Criar a estrutura b치sica de diret칩rios
  log "Criando diret칩rios para a inst칙ncia ${instancia_add}"
  sudo su - deploy <<EOF
  mkdir -p /home/deploy/${instancia_add}/
  mkdir -p /home/deploy/${instancia_add}/frontend
  mkdir -p /home/deploy/${instancia_add}/backend
  mkdir -p /home/deploy/${instancia_add}/redis
EOF

  # Verificar se os diret칩rios foram criados
  if [ ! -d "/home/deploy/${instancia_add}" ]; then
    log_error "Falha ao criar diret칩rio /home/deploy/${instancia_add}"
    exit 1
  fi
  
  log "Diret칩rios criados com sucesso"

  # Verificar se o c칩digo fonte local existe
  if [ -d "${codigo_fonte_local}" ]; then
    log "Usando c칩digo fonte local em: ${codigo_fonte_local}"
    # Copiar o c칩digo fonte local
    sudo cp -r ${codigo_fonte_local}/frontend/* /home/deploy/${instancia_add}/frontend/ 2>>"$LOG_FILE"
    sudo cp -r ${codigo_fonte_local}/backend/* /home/deploy/${instancia_add}/backend/ 2>>"$LOG_FILE"
    
    if [ $? -ne 0 ]; then
      log_error "Falha ao copiar o c칩digo fonte local"
      printf "${RED}Falha ao copiar o c칩digo fonte local. Tentando clonar do GitHub...${NC}\n"
      use_git=true
    else
      log "C칩digo fonte local copiado com sucesso"
      printf "${GREEN}C칩digo fonte local copiado com sucesso!${NC}\n"
      use_git=false
    fi
  else
    log "C칩digo fonte local n칚o encontrado em: ${codigo_fonte_local}. Tentando clonar do GitHub."
    use_git=true
  fi
  
  # Se o c칩digo fonte local n칚o funcionou ou n칚o existe, tentar clonar do GitHub
  if [ "$use_git" = true ]; then
    log "Clonando reposit칩rio: ${link_git}"
    sudo su - deploy <<EOF
    cd /home/deploy
    git clone ${link_git} /home/deploy/temp_${instancia_add} >> "$LOG_FILE" 2>&1
    
    # Verificar se o clone foi bem-sucedido
    if [ -d "/home/deploy/temp_${instancia_add}" ]; then
      # Copiar os conte칰dos para os diret칩rios apropriados
      cp -r /home/deploy/temp_${instancia_add}/frontend/* /home/deploy/${instancia_add}/frontend/ >> "$LOG_FILE" 2>&1
      cp -r /home/deploy/temp_${instancia_add}/backend/* /home/deploy/${instancia_add}/backend/ >> "$LOG_FILE" 2>&1
      
      # Remover o diret칩rio tempor치rio
      rm -rf /home/deploy/temp_${instancia_add}
      
      echo "Estrutura de diret칩rios criada com sucesso!" >> "$LOG_FILE"
    else
      echo "Falha ao clonar o reposit칩rio!" >> "$LOG_FILE"
      exit 1
    fi
EOF
  fi

  sleep 2
  
  # Verificar se os diret칩rios foram criados corretamente
  if [ ! -d "/home/deploy/${instancia_add}/frontend" ] || [ ! -d "/home/deploy/${instancia_add}/backend" ]; then
    log_error "Erro: Diret칩rios frontend ou backend n칚o foram criados corretamente!"
    printf "${RED}Erro: Diret칩rios frontend ou backend n칚o foram criados corretamente!${NC}\n"
    exit 1
  fi
  
  # Verificar se os arquivos package.json existem
  if [ ! -f "/home/deploy/${instancia_add}/frontend/package.json" ] || [ ! -f "/home/deploy/${instancia_add}/backend/package.json" ]; then
    log_error "Erro: Arquivos package.json n칚o foram encontrados! Verifique se o c칩digo fonte est치 correto."
    printf "${RED}Erro: Arquivos package.json n칚o foram encontrados! Verifique se o c칩digo fonte est치 correto.${NC}\n"
    exit 1
  else
    log "Diret칩rios e arquivos criados com sucesso!"
    printf "${GREEN}Diret칩rios e arquivos criados com sucesso!${NC}\n"
  fi
}

# Fun칞칚o para verificar o status da implanta칞칚o
verify_deployment() {
  print_banner
  printf "${WHITE} 游눹 Verificando status dos servi칞os...${GRAY_LIGHT}"
  printf "\n\n"
  log "Verificando status dos servi칞os"

  sleep 2

  printf "${YELLOW}Status do Redis:${NC}\n"
  docker service ls | grep redis-${instancia_add} | tee -a "$LOG_FILE"
  
  printf "\n${YELLOW}Status do Backend:${NC}\n"
  docker service ls | grep ${instancia_add}-backend | tee -a "$LOG_FILE"
  
  printf "\n${YELLOW}Status do Frontend:${NC}\n"
  docker service ls | grep ${instancia_add}-frontend | tee -a "$LOG_FILE"
  
  printf "\n${YELLOW}Logs do Backend:${NC}\n"
  docker service logs ${instancia_add}-backend_${instancia_add}-backend --tail 10 2>/dev/null | tee -a "$LOG_FILE" || echo "Ainda n칚o h치 logs dispon칤veis"
  
  printf "\n${YELLOW}Logs do Frontend:${NC}\n"
  docker service logs ${instancia_add}-frontend_${instancia_add}-frontend --tail 10 2>/dev/null | tee -a "$LOG_FILE" || echo "Ainda n칚o h치 logs dispon칤veis"
  
  printf "\n${GREEN}Verifica칞칚o conclu칤da! Acesse sua aplica칞칚o em:${NC}\n"
  printf "${CYAN_LIGHT}Frontend: ${frontend_url}${NC}\n"
  printf "${CYAN_LIGHT}Backend: ${backend_url}${NC}\n"
  
  log "Verifica칞칚o conclu칤da. Frontend: ${frontend_url}, Backend: ${backend_url}"
}

# Fun칞칚o para configurar o backend com Traefik
backend_traefik_setup() {
  print_banner
  printf "${WHITE} 游눹 Configurando Traefik (backend)...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando Traefik para o backend"

  sleep 2

  backend_hostname=$(echo "${backend_url/https:\/\/}")
  log "Backend hostname: ${backend_hostname}"

  # Criar arquivo docker-compose para o backend
  sudo su - deploy << EOF
  cat > /home/deploy/${instancia_add}/backend/docker-compose.yml << 'END'
version: '3.7'

services:
  ${instancia_add}-backend:
    image: node:20
    working_dir: /app
    volumes:
      - ./:/app
    command: node dist/server.js
    networks:
      - network_public
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.${instancia_add}-backend.rule=Host(\`${backend_hostname}\`)"
        - "traefik.http.routers.${instancia_add}-backend.entrypoints=websecure"
        - "traefik.http.services.${instancia_add}-backend.loadbalancer.server.port=${backend_port}"
        - "traefik.http.routers.${instancia_add}-backend.tls=true"
        - "traefik.http.routers.${instancia_add}-backend.tls.certresolver=letsencryptresolver"
        - "traefik.docker.network=network_public"

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o container como um servi칞o no swarm
  cd /home/deploy/${instancia_add}/backend
  docker stack deploy -c docker-compose.yml ${instancia_add}-backend >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar o Traefik para o backend"
    printf "${RED}Falha ao configurar o Traefik para o backend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Traefik configurado com sucesso para o backend"
    printf "${GREEN}Traefik configurado com sucesso para o backend!${NC}\n"
  fi

  sleep 2
}

# Fun칞칚o para configurar o frontend com Traefik
frontend_traefik_setup() {
  print_banner
  printf "${WHITE} 游눹 Configurando Traefik (frontend)...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando Traefik para o frontend"

  sleep 2

  frontend_hostname=$(echo "${frontend_url/https:\/\/}")
  log "Frontend hostname: ${frontend_hostname}"

  # Criar arquivo docker-compose para o frontend
  sudo su - deploy << EOF
  cat > /home/deploy/${instancia_add}/frontend/docker-compose.yml << 'END'
version: '3.7'

services:
  ${instancia_add}-frontend:
    image: node:20
    working_dir: /app
    volumes:
      - ./:/app
    command: node server.js
    networks:
      - network_public
    deploy:
      labels:
        - "traefik.enable=true"
        - "traefik.http.routers.${instancia_add}-frontend.rule=Host(\`${frontend_hostname}\`)"
        - "traefik.http.routers.${instancia_add}-frontend.entrypoints=websecure"
        - "traefik.http.services.${instancia_add}-frontend.loadbalancer.server.port=${frontend_port}"
        - "traefik.http.routers.${instancia_add}-frontend.tls=true"
        - "traefik.http.routers.${instancia_add}-frontend.tls.certresolver=letsencryptresolver"
        - "traefik.docker.network=network_public"

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o container como um servi칞o no swarm
  cd /home/deploy/${instancia_add}/frontend
  docker stack deploy -c docker-compose.yml ${instancia_add}-frontend >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar o Traefik para o frontend"
    printf "${RED}Falha ao configurar o Traefik para o frontend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Traefik configurado com sucesso para o frontend"
    printf "${GREEN}Traefik configurado com sucesso para o frontend!${NC}\n"
  fi

  sleep 2
}

# Modifica칞칚o da fun칞칚o backend_redis_create
backend_redis_create() {
  print_banner
  printf "${WHITE} 游눹 Criando Redis & Banco Postgres...${GRAY_LIGHT}"
  printf "\n\n"
  log "Criando Redis e configurando banco Postgres"

  sleep 2

  # Criar docker-compose.yml para o Redis
  sudo su - deploy << EOF
  mkdir -p /home/deploy/${instancia_add}/redis
  cat > /home/deploy/${instancia_add}/redis/docker-compose.yml << 'END'
version: '3.7'

services:
  redis-${instancia_add}:
    image: redis:latest
    command: redis-server --requirepass ${mysql_root_password}
    networks:
      - network_public
    deploy:
      replicas: 1
      restart_policy:
        condition: on-failure

networks:
  network_public:
    external: true
    name: network_public
END

  # Iniciar o Redis como servi칞o no swarm
  cd /home/deploy/${instancia_add}/redis
  docker stack deploy -c docker-compose.yml redis-${instancia_add} >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao criar o servi칞o Redis"
    printf "${RED}Falha ao criar o servi칞o Redis. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Servi칞o Redis criado com sucesso"
    printf "${GREEN}Servi칞o Redis criado com sucesso!${NC}\n"
  fi

  sleep 2

  # Configurar o banco de dados PostgreSQL
  log "Configurando banco de dados PostgreSQL"
  sudo su - root <<EOF
  sudo su - postgres
  createdb ${instancia_add} >> "$LOG_FILE" 2>&1
  psql << EOL
  CREATE USER ${instancia_add} SUPERUSER INHERIT CREATEDB CREATEROLE;
  ALTER USER ${instancia_add} PASSWORD '${mysql_root_password}';
  \q
EOL
  exit
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar o banco de dados PostgreSQL"
    printf "${RED}Falha ao configurar o banco de dados PostgreSQL. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Banco de dados PostgreSQL configurado com sucesso"
    printf "${GREEN}Banco de dados PostgreSQL configurado com sucesso!${NC}\n"
  fi

  sleep 2
}

# Modificar a fun칞칚o backend_set_env para usar o Redis em Docker Swarm
backend_set_env_modified() {
  print_banner
  printf "${WHITE} 游눹 Configurando vari치veis de ambiente (backend)...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando vari치veis de ambiente para o backend"

  sleep 2

  # ensure idempotency
  backend_url=$(echo "${backend_url/https:\/\/}")
  backend_url=${backend_url%%/*}
  backend_url=https://$backend_url
  log "Backend URL normalizada: ${backend_url}"

  # ensure idempotency
  frontend_url=$(echo "${frontend_url/https:\/\/}")
  frontend_url=${frontend_url%%/*}
  frontend_url=https://$frontend_url
  log "Frontend URL normalizada: ${frontend_url}"

sudo su - deploy << EOF
  cat <<[-]EOF > /home/deploy/${instancia_add}/backend/.env
NODE_ENV=
BACKEND_URL=${backend_url}
FRONTEND_URL=${frontend_url}
PROXY_PORT=443
PORT=${backend_port}

DB_DIALECT=postgres
DB_HOST=localhost
DB_PORT=5432
DB_USER=${instancia_add}
DB_PASS=${mysql_root_password}
DB_NAME=${instancia_add}

JWT_SECRET=${jwt_secret}
JWT_REFRESH_SECRET=${jwt_refresh_secret}

REDIS_URI=redis://:${mysql_root_password}@redis-${instancia_add}_redis-${instancia_add}:6379
REDIS_OPT_LIMITER_MAX=1
REGIS_OPT_LIMITER_DURATION=3000

USER_LIMIT=${max_user}
CONNECTIONS_LIMIT=${max_whats}
CLOSED_SEND_BY_ME=true

[-]EOF
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar vari치veis de ambiente para o backend"
    printf "${RED}Falha ao configurar vari치veis de ambiente para o backend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Vari치veis de ambiente configuradas com sucesso para o backend"
    printf "${GREEN}Vari치veis de ambiente configuradas com sucesso para o backend!${NC}\n"
  fi

  sleep 2
}

# Fun칞칚o para configurar vari치veis de ambiente do frontend
frontend_set_env_modified() {
  print_banner
  printf "${WHITE} 游눹 Configurando vari치veis de ambiente (frontend)...${GRAY_LIGHT}"
  printf "\n\n"
  log "Configurando vari치veis de ambiente para o frontend"

  sleep 2

  # ensure idempotency
  backend_url=$(echo "${backend_url/https:\/\/}")
  backend_url=${backend_url%%/*}
  backend_url=https://$backend_url

sudo su - deploy << EOF
  cat <<[-]EOF > /home/deploy/${instancia_add}/frontend/.env
REACT_APP_BACKEND_URL=${backend_url}
REACT_APP_HOURS_CLOSE_TICKETS_AUTO = 24
[-]EOF
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao configurar vari치veis de ambiente para o frontend"
    printf "${RED}Falha ao configurar vari치veis de ambiente para o frontend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Vari치veis de ambiente configuradas com sucesso para o frontend"
    printf "${GREEN}Vari치veis de ambiente configuradas com sucesso para o frontend!${NC}\n"
  fi

  sleep 2

sudo su - deploy << EOF
  cat <<[-]EOF > /home/deploy/${instancia_add}/frontend/server.js
//simple express server to run frontend production build;
const express = require("express");
const path = require("path");
const app = express();
app.use(express.static(path.join(__dirname, "build")));
app.get("/*", function (req, res) {
	res.sendFile(path.join(__dirname, "build", "index.html"));
});
app.listen(${frontend_port});

[-]EOF
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao criar o arquivo server.js para o frontend"
    printf "${RED}Falha ao criar o arquivo server.js para o frontend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Arquivo server.js criado com sucesso para o frontend"
    printf "${GREEN}Arquivo server.js criado com sucesso para o frontend!${NC}\n"
  fi

  sleep 2
}

# Fun칞칫es para instalar depend칡ncias e construir o backend/frontend
backend_node_dependencies_modified() {
  print_banner
  printf "${WHITE} 游눹 Instalando depend칡ncias do backend...${GRAY_LIGHT}"
  printf "\n\n"
  log "Instalando depend칡ncias do backend"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/backend
  npm install --force >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao instalar depend칡ncias do backend"
    printf "${RED}Falha ao instalar depend칡ncias do backend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Depend칡ncias do backend instaladas com sucesso"
    printf "${GREEN}Depend칡ncias do backend instaladas com sucesso!${NC}\n"
  fi

  sleep 2
}

backend_node_build_modified() {
  print_banner
  printf "${WHITE} 游눹 Compilando o c칩digo do backend...${GRAY_LIGHT}"
  printf "\n\n"
  log "Compilando o c칩digo do backend"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/backend
  npm run build >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao compilar o c칩digo do backend"
    printf "${RED}Falha ao compilar o c칩digo do backend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "C칩digo do backend compilado com sucesso"
    printf "${GREEN}C칩digo do backend compilado com sucesso!${NC}\n"
  fi

  sleep 2
}

backend_db_migrate_modified() {
  print_banner
  printf "${WHITE} 游눹 Executando db:migrate...${GRAY_LIGHT}"
  printf "\n\n"
  log "Executando migrations do banco de dados"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/backend
  npx sequelize db:migrate >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao executar migrations do banco de dados"
    printf "${RED}Falha ao executar migrations do banco de dados. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Migrations do banco de dados executadas com sucesso"
    printf "${GREEN}Migrations do banco de dados executadas com sucesso!${NC}\n"
  fi

  sleep 2
}

backend_db_seed_modified() {
  print_banner
  printf "${WHITE} 游눹 Executando db:seed...${GRAY_LIGHT}"
  printf "\n\n"
  log "Executando seeds do banco de dados"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/backend
  npx sequelize db:seed:all >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao executar seeds do banco de dados"
    printf "${RED}Falha ao executar seeds do banco de dados. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Seeds do banco de dados executadas com sucesso"
    printf "${GREEN}Seeds do banco de dados executadas com sucesso!${NC}\n"
  fi

  sleep 2
}

frontend_node_dependencies_modified() {
  print_banner
  printf "${WHITE} 游눹 Instalando depend칡ncias do frontend...${GRAY_LIGHT}"
  printf "\n\n"
  log "Instalando depend칡ncias do frontend"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/frontend
  npm install --force >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao instalar depend칡ncias do frontend"
    printf "${RED}Falha ao instalar depend칡ncias do frontend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "Depend칡ncias do frontend instaladas com sucesso"
    printf "${GREEN}Depend칡ncias do frontend instaladas com sucesso!${NC}\n"
  fi

  sleep 2
}

frontend_node_build_modified() {
  print_banner
  printf "${WHITE} 游눹 Compilando o c칩digo do frontend...${GRAY_LIGHT}"
  printf "\n\n"
  log "Compilando o c칩digo do frontend"

  sleep 2

  sudo su - deploy <<EOF
  cd /home/deploy/${instancia_add}/frontend
  npm run build >> "$LOG_FILE" 2>&1
EOF

  if [ $? -ne 0 ]; then
    log_error "Falha ao compilar o c칩digo do frontend"
    printf "${RED}Falha ao compilar o c칩digo do frontend. Verifique o log para mais detalhes.${NC}\n"
  else
    log "C칩digo do frontend compilado com sucesso"
    printf "${GREEN}C칩digo do frontend compilado com sucesso!${NC}\n"
  fi

  sleep 2
}

# Executar processo de instala칞칚o
print_banner
inquiry_options

# Continuar apenas se a op칞칚o 0 (instalar) foi selecionada
if [ -n "$instancia_add" ]; then
  log "Iniciando instala칞칚o da inst칙ncia: ${instancia_add}"
  
  # Verificar e configurar o modo Swarm
  system_check_swarm
  
  # Configurar Git e SSH para GitHub
  setup_git_config
  setup_github_ssh
  
  # Criar diret칩rios e clonar o reposit칩rio (vers칚o modificada)
  system_git_clone_modified
  
  # Configurar Redis e banco de dados
  backend_redis_create
  
  # Configurar vari치veis de ambiente
  backend_set_env_modified  # Usar a vers칚o modificada para Docker Swarm
  frontend_set_env_modified  # Configurar o frontend tamb칠m
  
  # Instalar depend칡ncias e construir o backend
  backend_node_dependencies_modified
  backend_node_build_modified
  backend_db_migrate_modified
  backend_db_seed_modified
  
  # Instalar depend칡ncias e construir o frontend
  frontend_node_dependencies_modified
  frontend_node_build_modified
  
  # Configurar Traefik para o backend e frontend
  backend_traefik_setup
  frontend_traefik_setup
  
  # Verificar o status da implanta칞칚o
  verify_deployment

  log "Instala칞칚o da inst칙ncia ${instancia_add} conclu칤da com sucesso!"
  printf "${GREEN}Instala칞칚o da inst칙ncia ${instancia_add} conclu칤da com sucesso!${NC}\n"
fi

# Finalizar o log
log "Script de instala칞칚o finalizado"